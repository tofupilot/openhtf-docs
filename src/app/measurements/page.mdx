export const metadata = {
  title: 'Measurements',
  description:
    'Learn how to capture and validate data within OpenHTF phases, including simple, multiple, validated, inline, multidimensional, and marginal measurements, with detailed examples and code snippets.',
}

# Measurements

Create measurements to capture and validate data within phases. {{ className: 'lead' }}

<Image
  src="/measurements-header.png"
  alt="OpenHTF Device Under Test (DUT) documentation section header with TofuPilot."
/>

## Overview

You can use measurements to capture and validate values during a test. 
These values can be [numeric](#numeric), [boolean](#boolean), or [string](#string), and may be either simple or [multidimensional](#multidimensional). 
Use the built-in validations in the decorator: you can define measurements with predefined units, types and validation rules.

Measurements are attached to Test Phases using `@openhtf.measures()` decorator.


<Note>
  Measurements should not be used for large data, such as binary files, which
  should be stored as [attachments](/attachments).
</Note>

## Numeric

By using numeric measurements, you can test values against a defined range or specific validation criteria. 

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units


@htf.measures(
    htf.Measurement("temperature")     # Declares a measurement 'temperature'
    .in_range(0, 100)                  # Define limits between 0 and 100
    .with_units(units.DEGREE_CELSIUS)  # Specifies the unit as Celsius
    .with_precision(1)                 # Rounds to 1 decimal place
)
def temperature_phase(test):
    test.measurements.temperature = 25 # Set the temperature value to 25Â°C


def main():
    test = htf.Test(temperature_phase)
    test.execute(lambda: "SI051AB7B0001")


if __name__ == "__main__":
    main()
```

### Validators

Validators are a list of callable objects to perform pass/fail checks.
You can parameter them in the decorator to provide unit, type, and validation infromation. 

<Properties>
  <Property name="name" type="string">
    Configure name of the measurement.
  </Property>
  <Property name="in_range(minimum, maximum)" type="Number, Number">
    Ensure the value is within the given range.
  </Property>
  <Property name=".equals(value)" type="Number">
    Ensures the measurement exactly matches the specified numerical value.
  </Property>
</Properties>


### Options

<Properties>
  <Property name="with_units(units)" type="UnitDescriptor">
    Define unit to the measurement (e.g., Celsius, Volts).   
  </Property>
  <Property name="with_precision(precision)" type="int">
    Round the value to the specified precision before validation.
  </Property>
</Properties>

```python {{ title: 'main.py'}}
import openhtf as htf
from openhtf.util import units

@htf.measures(
    htf.Measurement("validated_measurement")
    .in_range(0, 10)
    .with_units(units.SECOND)
)
def measure_seconds(test):
    test.measurements.validated_measurement = 5

@htf.measures(
    htf.Measurement("temperature")
    .equals(10)
    .with_units(units.DEGREE_CELSIUS)
)
def check_board_temperature(test):
    test.measurements.temperature = 10

def main():
    test = htf.Test(measure_seconds, check_board_temperature)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

## Boolean

You can use boolean measurements to validate a true/false condition.

```python {{ title: 'main.py' }}
import openhtf as htf

@htf.measures(
    htf.Measurement("is_led_switch_on")
    .equals(True)
)
def check_green_led(test):
    test.measurements.is_led_switch_on = True

def main():
    test = htf.Test(check_green_led)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Validators

<Properties>
  <Property name=".equals(value)" type="bool">
    Ensures the measurement exactly matches the specified boolean value.
  </Property>
</Properties>


## String
You can also validate a string.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units

@htf.measures(
    htf.Measurement("firmware_version")
    .equals("1.2.4")
)
def check_firmware_version(test):
    test.measurements.firmware_version = "1.2.4"

def main():
    test = htf.Test(check_firmware_version)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```


### Validators
<Properties>
  <Property name=".equals(value)" type="string">
    Ensures the measurement exactly matches the specified string.
  </Property>
</Properties>

## Multiple measurements

You can also use multiple measurements in a single test phase.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units

@htf.measures(
    htf.Measurement("is_connected").equals(True),
    htf.Measurement("firmware_version").equals("1.2.7"),
    htf.Measurement("temperature").in_range(0, 100).with_units(units.DEGREE_CELSIUS),
)
def multimeasurement_in_one_phase(test):
    test.measurements.is_connected = True
    test.measurements.firmware_version = "1.2.7" if test.measurements.is_connected else "N/A"
    test.measurements.temperature = 22.5

def main():
    test = htf.Test(multimeasurement_in_one_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

## TofuPilot integration

You can use <TofuPilotLink utmMedium="phases-integration" /> to analyse the measurements taken during the various phases of your tests, referred as steps in TofuPilot.

To enable TofuPilot integration, install the open-source Python client:

```sh
pip install tofupilot
```

Import `tofupilot` package and add the `with TofuPilot:` wrapper before the test execution:

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units

def first_phase(test):
    return htf.PhaseResult.CONTINUE

@htf.measures(
    htf.Measurement("temperature")
    .in_range(0, 100)
    .with_units(units.DEGREE_CELSIUS)
)
def temperature_phase(test):
    test.measurements.temperature = 25

def third_phase(test):
    return htf.PhaseResult.CONTINUE

def main():
    test = htf.Test(first_phase, temperature_phase, third_phase)
    with TofuPilot:
        test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

You can visualize the different measurements taken during a specific test.

<Image
  src="/measurements-header.png"
  alt="Run page showing the different steps performed for a Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

You can visualize the control chart of a specific measure (e.g. temperature) during time for several Units Under Test (UUT).

<Image
  src="/measurements-header.png"
  alt="Procedure page showing the control chart for a specific numeric measure for several Unit Under Test (UUT) in OpenHTF with TofuPilot"
/>

---

## Advanced use cases

You can leverage advanced OpenHTF options to handle complex measurement use cases.

### Documentation

You can add a description to your measurements.

```python {{ title: 'main.py' }}
import openhtf as htf

@htf.measures(
    measurements.Measurement('temperature')
    .in_range(0, 100)
    .with_units('C')
    .doc('This measurement tracks the ambient temperature during the test.')
)
def temperature_phase(test):
    test.measurements.temperature = 25

def main():
    test = htf.Test(temperature_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Argument Substitution

You can add a description to your measurements.

```python {{ title: 'main.py' }}
import openhtf as htf

@htf.measures(
    measurements.Measurement('test_result_{level}').with_args(level='high').equals('PASS')
)
def TestPhase(test):
    test.measurements.test_result_high = 'PASS'

def main():
    test = htf.Test(TemperaturePhase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Notification Callback

You can set a callback to trigger when a measurement is set.

```python {{ title: 'main.py' }}
import openhtf as htf

def my_callback():
    print("Measurement set!")

@htf.measures(
    measurements.Measurement('temperature').in_range(0, 100).with_units('C')
    .set_notification_callback(my_callback)
)
def TemperaturePhase(test):
    test.measurements.temperature = 25

def main():
    test = htf.Test(TemperaturePhase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Marginal Measurements

You can mark a measurement as marginal, indicating that while it passes validation, it is near the boundary of failure.

<Properties>
  <Property name="in_range(marginal_minimum, marginal_maximum)" type="Number, Number">
    Define a marginal measurement to obtain finer granularity of by how much a measurement is passing.
  </Property>
</Properties>

For finer granularity in test results, use marginal measurements. They set stricter limits within the acceptable range, giving detailed information about test performance. **This allows distinguishing between fully passing results and those close to failing, without affecting the overall phase outcome**, helping identify potential issues early.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units

@htf.measures(
    htf.Measurement('resistance')
    .with_units('ohm')
    .in_range(minimum=5, maximum=17, marginal_minimum=9, marginal_maximum=11)
)
def temperature_phase_with_marginal_measurements(test):
  test.measurements.resistance = 13

def main():
    test = htf.Test(temperature_phase_with_marginal_measurements)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

```python {{ title: 'Terminal'}}
================= test: openhtf_test  outcome: PASS (MARGINAL) =================
```

### Conditional Validation

You can apply conditional validation based on outcomes.

```python {{ title: 'main.py' }}
import openhtf as htf

@htf.measures(
    measurements.Measurement('power_output').in_range(0, 100)
    .validate_on({'PASS': lambda x: x > 50})
)
def PowerTestPhase(test):
    test.measurements.power_output = 75

def main():
    test = htf.Test(PowerTestPhase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Transformation Function

You can modify measurement values before validation.

```python {{ title: 'main.py' }}
import openhtf as htf

@htf.measures(
    measurements.Measurement('voltage').in_range(0, 10)
    .with_transform(lambda x: x * 1.1).with_units('V')
)
def VoltagePhase(test):
    test.measurements.voltage = 5

def main():
    test = htf.Test(VoltagePhase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Multidimensional

Multidimensional measurements allow for capturing data that spans multiple coordinates, such as time-series data or data across multiple levels or categories.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.util import units
import random
import time

@htf.measures(
    htf.Measurement("voltage_over_time")
    .with_dimensions(units.SECOND, units.VOLT)
)
def voltage_measurement_phase(test):
    for t in range(10):
        timestamp = t
        voltage = round(random.uniform(3.3, 3.5), 2)
        test.measurements.voltage_over_time[timestamp, voltage] = 0
        time.sleep(0.1)

def main():
    test = htf.Test(voltage_measurement_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == "__main__":
    main()
```

### Validators

<Properties>
  <Property name=".in_range(min_value, max_value)">
    Can be applied to each value in the multidimensional set.{' '}
  </Property>
</Properties>

### Options

<Properties>
  <Property name=".with_dimensions(*dims)">
    Adds multiple units for multidimensional measurements (e.g., time,
    frequency).
  </Property>
</Properties>