# Outputs

Creating structured test results is essential for production testing traceability, and analytics. OpenHTF generates structured JSON files and offers customizable output formats to meet your specific needs.

{{ className: 'lead' }}

## Standard JSON output

To enable the default JSON output format in OpenHTF, simply specify the output mechanism with one callback.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.output.callbacks import json_factory

@htf.measures(htf.Measurement('voltage'), htf.Measurement('current'))
def electrical_measurements(test):
    test.measurements.voltage = 12.0  # Volts
    test.measurements.current = 1.5  # Amperes

def main():
    test = htf.Test(electrical_measurements)
    test.add_output_callbacks(
        json_factory.OutputToJSON('./test_results.json', indent=2)
    )
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

Here's an example of the JSON output. Note that detailed metadata, phase options, and log records are also logged but not displayed here for brevity:

```javascript {{ title: 'test_results.json' }}
{
  "dut_id": "DeviceUnderTest123",
  "start_time_millis": 1720126751249,
  "end_time_millis": 1720126751250,
  "outcome": "PASS",
  "outcome_details": [],
  "marginal": false,
  "metadata": {
    "test_name": "openhtf_test",
    "config": {
      "attachments_directory": null,
      "plug_teardown_timeout_s": 0,
      "allow_unset_measurements": false,
      "station_id": "Juliens-Air",
      "cancel_timeout_s": 2,
      "stop_on_first_failure": false,
      "capture_source": false
    }
  },
  "phases": [
    {
      "measurements": {},
      "name": "trigger_phase",
      "outcome": "PASS",
      ...
    },
    {
      "measurements": {
        "voltage": {
          "name": "voltage",
          "outcome": "PASS",
          "measured_value": 12.0
        },
        "current": {
          "name": "current",
          "outcome": "PASS",
          "measured_value": 1.5
        }
      },
      "name": "electrical_measurements",
      "outcome": "PASS",
      ...
    }
  ],
  ...
}
```

## Custom output

You can also implement custom output mechanisms if the built-in ones do not meet your requirements. This involves creating a function that handles the test record and adding it as an output callback.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.output import callbacks

def custom_output_callback(test_record):
    with open('./custom_output.txt', 'w') as f:
        f.write('Custom Output\n')
        f.write(f'DUT ID: {test_record.dut_id}\n')
        f.write(f'Outcome: {test_record.outcome}\n')
        for phase in test_record.phases:
            f.write(f'Phase: {phase.name}\n')
            for measurement in phase.measurements.values():
                f.write(f'{measurement.name}: {measurement.value}\n')

@htf.measures(htf.Measurement('temperature').with_units('C'))
def temperature_measurement(test):
    test.measurements.temperature = 25  # Celsius

def main():
    test = htf.Test(temperature_measurement)
    test.add_output_callbacks(custom_output_callback)
    test.execute(test_start=lambda: 'DeviceUnderTest456')

if __name__ == '__main__':
    main()
```

The output file will then be:

```txt {{ title: 'custom_output.txt' }}
Custom Output
DUT ID: DeviceUnderTest456
Outcome: Outcome.PASS
Phase: trigger_phase
Phase: temperature_measurement
```
