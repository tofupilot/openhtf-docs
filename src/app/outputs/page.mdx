export const metadata = {
  title: 'Test Outputs | OpenHTF',
  description:
    'Learn how to create structured test results with OpenHTF. This guide covers generating JSON output and implementing custom output mechanisms with detailed examples and code snippets.',
}

# Outputs

Creating structured test results is essential for production testing traceability, and analytics. OpenHTF generates structured JSON files and offers customizable output formats to meet your specific needs. {{ className: 'lead' }}

## JSON Output

To enable the default JSON output format in OpenHTF, simply specify the output mechanism with one callback.

```python {{ title: 'main.py' }}
from openhtf import Test, PhaseResult
from openhtf.output.callbacks import json_factory

def power_on_test(test):
    print("Power on.")
    return PhaseResult.CONTINUE

def main():
    test = Test(power_on_test)

    # Add a JSON output callback to export the results to a JSON file
    test.add_output_callbacks(json_factory.OutputToJSON(
        "test_result.json",  # The name of the output file
        indent=2             # Pretty-printing the JSON with an indentation of 2 spaces
    ))

    # Execute the test
    test.execute(lambda: "DeviceUnderTest123")

if __name__ == "__main__":
    main()
```

Here's an excerpt of the JSON output. Note that detailed metadata, phase options, and log records are also logged but not displayed here for brevity:

```javascript {{ title: 'test_results.json' }}
{
  "dut_id": "DeviceUnderTest123",
  "start_time_millis": 1720126751249,
  "end_time_millis": 1720126751250,
  "outcome": "PASS",
  "outcome_details": [],
  "marginal": false,
  "metadata": {
    "test_name": "openhtf_test",
    "config": {
      "attachments_directory": null,
      "plug_teardown_timeout_s": 0,
      "allow_unset_measurements": false,
      "station_id": "Computer Name",
      "cancel_timeout_s": 2,
      "stop_on_first_failure": false,
      "capture_source": false
    }
  },
  "phases": [
    {
      "measurements": {},
      "name": "trigger_phase",
      "outcome": "PASS",
      "start_time_millis": 1725366624798,
      "end_time_millis": 1725366624798,
      ...
    },
    {
      "measurements": {},
      "name": "power_on_test",
      "outcome": "PASS",
      "start_time_millis": 1725366624798,
      "end_time_millis": 1725366624798,
      ...
    }
  ],
  ...
}
```

## Custom Output

You can also implement custom output mechanisms if the built-in ones do not meet your requirements. This involves creating a function that handles the test record and adding it as an output callback.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.output import callbacks

def custom_output_callback(test_record):
    with open('./custom_output.txt', 'w') as f:
        f.write('Custom Output\n')
        f.write(f'DUT ID: {test_record.dut_id}\n')
        f.write(f'Outcome: {test_record.outcome}\n')
        for phase in test_record.phases:
            f.write(f'Phase: {phase.name}\n')
            for measurement in phase.measurements.values():
                f.write(f'{measurement.name}: {measurement.value}\n')

def power_on_test(test):
    print("Power on.")
    return PhaseResult.CONTINUE

def main():
    test = Test(power_on_test)

    test.add_output_callbacks(custom_output_callback)
    test.execute(test_start=lambda: "DeviceUnderTest456")

    # Execute the test
    test.execute(lambda: "DeviceUnderTest456")

if __name__ == "__main__":
    main()
```

The output file will then be:

```txt {{ title: 'custom_output.txt' }}
Custom Output
DUT ID: DeviceUnderTest456
Outcome: Outcome.PASS
Phase: trigger_phase
Phase: power_on_test
```
