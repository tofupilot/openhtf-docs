export const metadata = {
  title: 'Test Phases | OpenHTF',
  description:
    'Discover how to define and execute test phases using OpenHTF. This guide covers phase creation, phase results, and phase options with detailed examples and code snippets.',
}

# Phases

Test phases in OpenHTF are Python functions that execute specific tasks during the test process. They can perform measurements, control devices, and handle various other test-related activities. {{ className: 'lead' }}

<Note>OpenHTF's phases are similar to steps in TofuPilot.</Note>

## Definition

Let's create a simple OpenHTF test with three phases that log messages and continue sequentially.

```python {{ title: 'main.py' }}
import openhtf as htf

def first_phase(test):
    return htf.PhaseResult.CONTINUE

def second_phase(test):
    return htf.PhaseResult.CONTINUE

def third_phase(test):
    return htf.PhaseResult.CONTINUE

if __name__ == '__main__':
    test = htf.Test(first_phase, second_phase, third_phase)
    test.execute(lambda: "DeviceUnderTest123")
```

The console returns:

```txt
======================= test: openhtf_test  outcome: PASS ======================
```

## Phase Results

Specific `PhaseResult` can be returned by test phases to indicate the next action after phase execution.

```python {{ title: 'main.py' }}
import openhtf as htf
import random

# Define a phase that will always pass
def pass_phase(test):
    return htf.PhaseResult.CONTINUE

# Define a phase that retries on failure
def retry_phase(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.REPEAT

# Define a phase that will always fail
def fail_phase(test):
    return htf.PhaseResult.STOP

# Define and execute the test
if __name__ == '__main__':
    test = htf.Test(pass_phase, retry_phase, fail_phase)
    test.execute(lambda: "DeviceUnderTest123")
```

The console returns:

```txt
======================= test: openhtf_test  outcome: FAIL ======================
```

The following `PhaseResult` can be provided:

<Properties>
  <Property name="PhaseResult.CONTINUE">
    Process phase measurement outcomes and execute the next phase.
  </Property>
  <Property name="PhaseResult.FAIL_AND_CONTINUE">
    Mark phase as failed and execute the next phase.
  </Property>
  <Property name="PhaseResult.REPEAT">
    Execute the same phase again, ignoring measurement outcomes.
  </Property>
  <Property name="PhaseResult.SKIP">
    Ignore measurement outcomes and execute the next phase.
  </Property>
  <Property name="PhaseResult.STOP">
    Stop executing, indicating a failure.
  </Property>
  <Property name="PhaseResult.FAIL_SUBTEST">
    Stop the current subtest and mark as failed, then continue.
  </Property>
</Properties>

## Phase Options

Specific options can be set for test phases to override default behaviors using the `@htf.PhaseOptions` decorator.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf import PhaseOptions, PhaseResult
import random

# Define a phase with a custom name and timeout
@htf.PhaseOptions(name='Always Pass Phase', timeout_s=5)
def pass_phase(test):
    return PhaseResult.CONTINUE

# Define a phase that retries on failure with a maximum repeat limit
@htf.PhaseOptions(repeat_limit=3)
def retry_phase(test):
    if random.choice([True, False]):
        return PhaseResult.CONTINUE
    else:
        return PhaseResult.REPEAT

# Define a phase that will always fail, but only runs if a condition is met
@htf.PhaseOptions(run_if=lambda: random.choice([True, False]))
def conditional_fail_phase(test):
    return PhaseResult.STOP

# Define and execute the test
if __name__ == '__main__':
    # Create the test instance with the defined phases
    test = htf.Test(pass_phase, retry_phase, conditional_fail_phase)
    # Execute the test
    test.execute(lambda: "DeviceUnderTest123")
```

The console returns:

```txt
======================= test: openhtf_test  outcome: FAIL ======================
```

The following `@htf.PhaseOptions` can be provided:

<Properties>
  <Property name="name" type="string">
    Override for the name of the phase.
  </Property>
  <Property name="timeout_s" type="float">
    Timeout for the phase, in seconds.
  </Property>
  <Property name="run_if" type="callable">
    Callback to decide whether to run the phase.
  </Property>
  <Property name="requires_state" type="bool">
    Pass the whole TestState if True, otherwise pass TestApi.
  </Property>
  <Property name="force_repeat" type="bool">
    Force the phase to repeat up to repeat_limit times.
  </Property>
  <Property name="repeat_on_measurement_fail" type="bool">
    Repeat phase on measurement failure.
  </Property>
  <Property name="repeat_on_timeout" type="bool">
    Repeat phase on timeout.
  </Property>
  <Property name="repeat_limit" type="int or None">
    Maximum number of repeats, None for infinite.
  </Property>
  <Property name="run_under_pdb" type="bool">
    Run the phase under the Python Debugger.
  </Property>
  <Property name="phase_name_case" type="string">
    Case formatting options for phase name.
  </Property>
  <Property name="stop_on_measurement_fail" type="bool">
    Stop the test if any measurements fail.
  </Property>
</Properties>
