export const metadata = {
  title: 'Phases',
  description:
    'Discover how to define and execute test phases using OpenHTF. This guide covers phase creation, phase results, and phase options with detailed examples and code snippets.',
}

# Phases

You can organize your test flow by breaking it down into multiple phases. {{ className: 'lead' }}

<Image
  src="/phases-header.png"
  alt="OpenHTF Device Under Test (DUT) documentation section header with TofuPilot."
/>

## Overview

Hardware tests typically consist of multiple test steps, which OpenHTF refers to as phases. Phases usually are setup, teardown or measurements steps.

We recommend performing a single read or write operation on the unit under test per phase. One or several [measurements](/measurements) will be added per phase, depending on the number of controls to perform on the data collected.

By integrating <TofuPilotLink utmMedium="phases-overview"/>, you get precise analytics on failure rates and phase durations.

## Definition

Phases are standard Python functions that take the `test` object as an input argument and return a `PhaseResult`.

```python {{ title: 'main.py' }}
import openhtf as htf

def setup_phase(test):
    return htf.PhaseResult.CONTINUE

def test_voltage_phase(test):
    return htf.PhaseResult.CONTINUE

def teardown_phase(test):
    return htf.PhaseResult.CONTINUE

def main():
    # Run the test on serial number SI051AB7B0001 with the 3 phases to be executed
    test = htf.Test(setup_first_phase, test_voltage_phase, teardown_phase) 
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```

To be executed, they must be individually added to the test definition.

## Results

You can choose the execution of the next phase by defining the following `PhaseResult`:

<Properties>
  <Property name="PhaseResult.CONTINUE" type="default">
    Set the phase outcome to `PASS` and execute the next phase.
  </Property>
  <Property name="PhaseResult.STOP">
    Set the phase outcome to `FAIL` and stop executing the test.
  </Property>
  <Property name="PhaseResult.REPEAT">
    Repeat the phase, ignoring current measurement outcomes. If exceeded the `repeat_limit`, it triggers a `PhaseResult.STOP`.
  </Property>
  <Property name="PhaseResult.FAIL_AND_CONTINUE">
    Set the phase outcome to `FAIL` and execute the next phase.
  </Property>
  <Property name="PhaseResult.SKIP">
    Set the phase outcome to `SKIP`, ignore measurement outcomes, and execute the next phase. 
  </Property>
</Properties>


```python {{ title: 'main.py' }}
import openhtf as htf
import random

# Always pass
def pass_phase(test):
    return htf.PhaseResult.CONTINUE

# Retries on failure
def retry_phase(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.REPEAT

# Fail and stop the test
def fail_phase(test):
    return htf.PhaseResult.STOP

def main():
    test = htf.Test(pass_phase, retry_phase, fail_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```

The console returns:

```txt
======================= test: openhtf_test  outcome: FAIL ======================
```

## Options

You can use the `@openhtf.PhaseOptions` decorator to modify phase execution behavior.

<Properties>
  <Property name="timeout_s" type="float (default=None)">
    Timeout for the phase, in seconds.
  </Property>
  <Property name="repeat_limit" type="int (default=None)">
      Maximum number of repeats.  None indicates a phase will be repeated infinitely as long as `PhaseResult.REPEAT` is returned.
  </Property>
</Properties>


```python {{ title: 'main.py' }}
import openhtf as htf
import random

@htf.PhaseOptions(timeout_s=5)
def pass_phase(test):
    return htf.PhaseResult.CONTINUE

# Retries on failure with a maximum repeat limit
@htf.PhaseOptions(repeat_limit=3)
def retry_phase(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.REPEAT

def main():
    test = htf.Test(pass_phase, retry_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```

Find more advanced options in [Advanced use cases](#advanced-use-cases).


## TofuPilot integration

The <TofuPilotLink utmMedium="phases-integration" /> integration provides immediate compatibility with OpenHTF phases, referred to as steps in TofuPilot.

To enable TofuPilot integration, install the open-source Python client:

```sh
pip install tofupilot
```

And add the `tofupilot.synch` callback before the test execution:

```python {{ title: 'main.py' }}
from openhtf import Test, PhaseResult
import tofupilot

def first_phase(test):
    return htf.PhaseResult.CONTINUE

def second_phase(test):
    return htf.PhaseResult.SKIP

def third_phase(test):
    return htf.PhaseResult.STOP

def main():
    test = htf.Test(first_phase, second_phase, third_phase)
    test.add_output_callbacks(tofupilot.synch()) # Add synch callback before test execution
    test.execute(SI051AB7B0001)

if __name__ == '__main__':
    main()
```

You can see the test phases on each run page, without measurements for now.

<Image
  src="/phases-page-run.png"
  alt="Unit page showing all test runs for a Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

You can click on a phase to compare its recent performance, like the duration between runs.

<Image
  src="/phases-page-procedure-duration.png"
  alt="Unit page showing all test runs for a Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

You can also compare the detailed first yield for each phase.

<Image
  src="/phases-page-procedure-fpy.png"
  alt="Unit page showing all test runs for a Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

---

## Advanced use cases

You can leverage advanced OpenHTF options to handle more complex phase execution cases.

### Override phase name

You can replace the default phase name or change the case formatting with these following `PhaseOptions`:

<Properties>
  <Property name="name" type="text (default=None)">
    Override for the name of the phase.
  </Property>
  <Property name="phase_name_case" type="PhaseNameCase (default=KEEP)">
    Change phase name case to CamelCase using `CAMEL`.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf import PhaseNameCase

@htf.PhaseOptions(name="new_phase_name", phase_name_case=PhaseNameCase.CAMEL)
def example_phase(test):
    return htf.PhaseResult.CONTINUE

def main():
  test = htf.Test(example_phase)
  test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
  main()

```

### Change repeat behavior

You can repeat or stop phases under specific conditions with these following `PhaseOptions`:

<Properties>
  <Property name="repeat_limit" type="int (default=None)">
      Define a maximum number of repeats. None indicates that a phase will be repeated infinitely as long as `PhaseResult.REPEAT` is returned.
  </Property>
  <Property name="force_repeat" type="bool (default=False)">
    Force the phase to repeat up to `repeat_limit` times.
  </Property>
  <Property name="repeat_on_timeout" type="bool (default=False)">
     Repeat phase on timeout.
  </Property>
  <Property name="repeat_on_measurement_fail" type="bool (default=False)">
    Force phase with failed measurements to repeat up to `repeat_limit` times.
  </Property>
  <Property name="stop_on_measurement_fail" type="bool (default=False) ">
   Stop the test if any measurements fail.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

@htf.PhaseOptions(force_repeat=True, repeat_limit=3)
def repeat_phase(test):
    test.logger.info('This phase always repeats 3 times.')
    return PhaseResult.CONTINUE

@htf.PhaseOptions(repeat_on_timeout=True)
def timeout_phase(test):
    test.logger.info('This phase may repeat on timeout.')
    return PhaseResult.CONTINUE

@htf.PhaseOptions(repeat_on_measurement_fail=True, repeat_limit=4)
def timeout_phase(test):
    test.logger.info('This phase will repeat until success or limit reached.')
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.FAIL

def main():
    test = htf.Test(repeat_phase, timeout_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```
### Python Debugger
<Properties>
  <Property name="run_under_pdb" type="bool (default=False)">
    Run the phase under the Python Debugger. When
      setting this option, increase the phase `timeout_s` as well because the
      timeout will still apply when under the debugger.
  </Property>
  <Property name="run_if" type="bool or callback (default=None)">
    Callback decides whether to run the phase or not. If it is not executed, the phase will not be logged either.  
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

# Will always fail, but only runs if a condition is met
@htf.PhaseOptions(run_if=lambda: random.choice([True, False]))
def conditional_fail_phase(test):
    return htf.PhaseResult.STOP

def main():
    test = htf.Test(conditional_fail_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```

### Requires state
You can use this `PhaseOptions` when a phase needs to manage internal test details, such as wrapping or controlling other phases.

<Properties>
  <Property name="requires_state" type="bool (default=False)">
    Pass the complete `TestState` object instead of default `TestApi`. 
  </Property>
</Properties>

``` python {{ title: 'main.py' }}
import openhtf as htf

# Simple test phase that checks a condition
@htf.PhaseOptions()
def check_condition(test):
    test.logger.info("Condition checked")
    return htf.PhaseResult.CONTINUE

# Phase that requires TestState to invoke other phase
@htf.PhaseOptions(requires_state=True)
def conditional_phase(test_state):
    test_state.logger.info("Running check_condition phase")
    check_condition(test_state)  # Manually invoke another phase

def main():
    # Define the test with the conditional phase
    test = htf.Test(conditional_phase)
    test.execute(lambda: "SI051AB7B0001")

if __name__ == '__main__':
    main()
```

