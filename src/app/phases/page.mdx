export const metadata = {
  title: 'Phases',
  description:
    'Discover how to define and execute test phases using OpenHTF. This guide covers phase creation, phase results, and phase options with detailed examples and code snippets.',
}

# Phases

Organize your test flow by breaking it down into multiple phases. {{ className: 'lead' }}

<Image
  src="/phases-header.png"
  alt="OpenHTF Device Under Test (DUT) documentation section header with TofuPilot."
/>

## Overview

A hardware test typically consists of several steps that perform measurements and validation. OpenHTF refers to these steps as phases and allows for precise management of their execution based on the results obtained.

With the <TofuPilotLink utmMedium="phases-overview"/> integration, you get precise analytics on phase failure rates and durations across test runs.

## Syntax

Phases are Python functions that take the `test` object as an argument and must be added to the `Test` object to be executed.
They have an outcome that is set manually with a `PhaseResult` or automatically via a measurement validation function, which we'll cover on the next page. 

```python {{ title: 'main.py' }}
import openhtf as htf

def phase_one(test):
    return htf.PhaseResult.CONTINUE

def phase_two(test):
    return htf.PhaseResult.CONTINUE

def main():
    test = htf.Test(phase_one, phase_two)
    test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

## Results

You can set the next phase's outcome by setting the `PhaseResult`:

<Properties>
  <Property name="PhaseResult.CONTINUE" type="default">
    Set the phase outcome to `PASS` and execute the next phase.
  </Property>
  <Property name="PhaseResult.STOP">
    Set the phase outcome to `FAIL` and stop executing the test.
  </Property>
  <Property name="PhaseResult.REPEAT">
    Repeat the phase, ignoring current measurement outcomes. If exceeded the
    `repeat_limit`, it triggers a `PhaseResult.STOP`.
  </Property>
  <Property name="PhaseResult.FAIL_AND_CONTINUE">
    Set the phase outcome to `FAIL` and execute the next phase.
  </Property>
  <Property name="PhaseResult.SKIP">
    Set the phase outcome to `SKIP`, ignore current measurement outcomes, and
    execute the next phase.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

# Always pass
def phase_pass(test):
    return htf.PhaseResult.CONTINUE

# Retries on failure
def phase_retry(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.REPEAT

# Fail and stop the test
def phase_fail(test):
    return htf.PhaseResult.STOP

def main():
    test = htf.Test(phase_pass, phase_repeat, phase_fail)
    test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

```txt {{ title: 'Terminal' }}
======================= test: openhtf_test  outcome: FAIL ======================
```

## Options

You can use the `@openhtf.PhaseOptions` decorator to modify phase execution behavior.

<Properties>
  <Property name="timeout_s" type="float">
    Timeout for the phase, in seconds.
  </Property>
  <Property name="repeat_limit" type="int or None">
    Maximum number of repeats. `None` to repeated infinitely as long as
    `PhaseResult.REPEAT` is returned.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

@htf.PhaseOptions(timeout_s=5)
def phase_pass(test):
    return htf.PhaseResult.CONTINUE

@htf.PhaseOptions(repeat_limit=3) # Retries up to 3 times in case of failure
def phase_retry(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.REPEAT

def main():
    test = htf.Test(pass_phase, retry_phase)
    test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

For more options, check the [advanced use cases](#advanced-use-case).

## TofuPilot integration

The <TofuPilotLink utmMedium="phases-integration" /> integration is natively compatible with OpenHTF phases, referred to as steps in TofuPilot.

To integrate TofuPilot, install the open-source client:

```sh
pip install tofupilot
```

Add it to your test like this:

```python {{ title: 'main.py' }}
import openhtf as htf

def phase_one(test):
    return htf.PhaseResult.CONTINUE

def phase_two(test):
    return htf.PhaseResult.CONTINUE

def main():
    test = htf.Test(phase_one, phase_two)
    with TofuPilot:
      test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

You can visualize the test phases in the steps on each run page.

<Image
  src="/phases-page-run.png"
  alt="Run page showing the different steps performed for a Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

You can click on a phase to compare its recent performance, like the duration between runs.

<Image
  src="/phases-page-procedure-duration.png"
  alt="Procedure page showing the durations for several Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

You can also compare the detailed first yield for each phase.

<Image
  src="/phases-page-procedure-fpy.png"
  alt="Procedure page showing the first-pass yield for several Unit Under Test (UUT) in OpenHTF with TofuPilot."
/>

---

## Advanced use cases

You can leverage advanced OpenHTF options to handle more complex phase execution cases.

### Override phase name

You can replace the default phase name or change the case formatting:

<Properties>
  <Property name="name" type="text">
    Override for the name of the phase.
  </Property>
  <Property name="phase_name_case" type="PhaseNameCase">
    Change phase name case to CamelCase using `CAMEL`.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf import PhaseNameCase

@htf.PhaseOptions(name="new_phase_name", phase_name_case=PhaseNameCase.CAMEL)
def example_phase(test):
    return htf.PhaseResult.CONTINUE

def main():
  test = htf.Test(example_phase)
  test.execute(lambda: "PCB001")

if __name__ == '__main__':
  main()
```

### Document phase - TODO

You can document your phase by using the phase descriptor `doc`

### Change repeat behavior

You can repeat or stop phases under specific conditions with these following `PhaseOptions`:

<Properties>
  <Property name="repeat_limit" type="int">
    Define a maximum number of repeats. None indicates that a phase will be
    repeated infinitely as long as `PhaseResult.REPEAT` is returned.
  </Property>
  <Property name="force_repeat" type="bool">
    Force the phase to repeat up to `repeat_limit` times.
  </Property>
  <Property name="repeat_on_timeout" type="bool (default=False)">
    Repeat phase on timeout.
  </Property>
  <Property name="repeat_on_measurement_fail" type="bool (default=False)">
    Force phase with failed measurements to repeat up to `repeat_limit` times.
  </Property>
  <Property name="stop_on_measurement_fail" type="bool (default=False) ">
    Stop the test if any measurements fail.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

@htf.PhaseOptions(force_repeat=True, repeat_limit=3)
def repeat_phase(test):
    return htf.PhaseResult.CONTINUE

@htf.PhaseOptions(repeat_on_timeout=True)
def timeout_phase(test):
    return htf.PhaseResult.CONTINUE

@htf.PhaseOptions(stop_on_measurement_fail=True)
def random_fail_phase(test):
    if random.choice([True, False]):
        return htf.PhaseResult.CONTINUE
    else:
        return htf.PhaseResult.STOP

# This test won't be run if random_fail_phase is FAIL.
def always_true_phase(test):
    return htf.PhaseResult.CONTINUE

def main():
    test.execute(lambda: "PCB001")
    test = htf.Test(repeat_phase, timeout_phase, random_fail_phase, always_true_phase)

if __name__ == "__main__":
    main()
```

### Python Debugger

<Properties>
  <Property name="run_under_pdb" type="bool (default=False)">
    Run the phase under the Python Debugger. When setting this option, increase
    the phase `timeout_s` as well because the timeout will still apply when
    under the debugger.
  </Property>
  <Property name="run_if" type="bool or callback">
    Callback decides whether to run the phase or not. If it is not executed, the
    phase will not be logged either.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf
import random

# Will always fail, but only runs if a condition is met
@htf.PhaseOptions(run_if=lambda: random.choice([True, False]))
def conditional_fail_phase(test):
    return htf.PhaseResult.STOP

def main():
    test = htf.Test(conditional_fail_phase)
    test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

### Requires state

You can use this `PhaseOptions` when a phase needs to manage internal test details, such as wrapping or controlling other phases.

<Properties>
  <Property name="requires_state" type="bool (default=False)">
    Pass the complete `TestState` object instead of default `TestApi`.
  </Property>
</Properties>

```python {{ title: 'main.py' }}
import openhtf as htf

# Simple test phase that checks a condition
@htf.PhaseOptions()
def check_condition(test):
    test.logger.info("Condition checked")
    return htf.PhaseResult.CONTINUE

# Phase that requires TestState to invoke other phase
@htf.PhaseOptions(requires_state=True)
def conditional_phase(test_state):
    test_state.logger.info("Running check_condition phase")
    check_condition(test_state)  # Manually invoke another phase

def main():
    # Define the test with the conditional phase
    test = htf.Test(conditional_phase)
    test.execute(lambda: "PCB001")

if __name__ == '__main__':
    main()
```

### Phase Groups - TODO

- Use to defined Main, Setup and Teardown
- Options: repeat, name, timeout, phases

```
test = htf.Test(
      htf.PhaseGroup(
          setup=[setup_phase],
          main=[error_main_phase, main_phase],
          teardown=[teardown_phase],
      ))
  test.execute()
```
