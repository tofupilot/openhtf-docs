# Plugs

OpenHTF provides a powerful plugin system, known as "plugs," which allows to abstract hardware interactions. They can be used to encapsulate reusable test logic, hardware interfaces, or any other functionality you need. {{ className: 'lead' }}

A plug is a class that inherits from `plugs.BasePlug` and can implement a `tearDow`. They can wrap existing Python objects for seamless integrationâ€‹.

## Simple plug

This example demonstrates a simple plug that maintains a value and increments it. The plug supports a teardown process and maintains state across test phases. Plugs can be injected into test phases using the `@htf.plug` decorator.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.core import base_plugs

class ExamplePlug(base_plugs.BasePlug):
    def __init__(self, increment_size=1):
        self.increment_size = increment_size
        self.value = 0

    def tearDown(self):
        self.logger.info('Tearing down %s', self)

    def increment(self):
        self.value += self.increment_size
        return self.value - self.increment_size

@htf.plug(my_plug=ExamplePlug)
def my_test_phase(test, my_plug):
    result = my_plug.increment()
    test.logger.info('Plug incremented value to: %s', result)

def main():
    test = htf.Test(my_test_phase)
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

## Plug configuration and output

Plugs can also have their own configurations. You can declare configuration options and load them similarly to how you do it for tests.

```python {{ title: 'main.py' }}
import openhtf as htf
import logging
from openhtf.core import base_plugs
from openhtf.util import conf
from openhtf.output.callbacks import json_factory

# Define configuration options
conf.declare('example_plug_increment_size', default_value=1, description='Increment constant for example plug.')

class ExamplePlug(base_plugs.BasePlug):
    def __init__(self):
        self.increment_size = conf.example_plug_increment_size
        self.value = 0

    def __str__(self):
        return '<%s: %s>' % (type(self).__name__, self.value)

    def tearDown(self):
        self.logger.info('Tearing down %s', self)

    def increment(self):
        self.value += self.increment_size
        return self.value - self.increment_size

@htf.plug(my_plug=ExamplePlug)
def my_test_phase(test, my_plug):
    result = my_plug.increment()
    test.logger.info('Plug incremented value to: %s', result)

def main():
    logging.basicConfig(level=logging.INFO)
    test = htf.Test(my_test_phase)
    test.add_output_callbacks(json_factory.OutputToJSON('./test_results.json', indent=2))
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

When output is enabled, the plug's activity will be included in the JSON output file.

```javascript {{ title: 'test_results.json' }}
{
  "dut_id": "DeviceUnderTest123",
  ...
  "log_records": [
    ...
    {
      "level": 20,
      "logger_name": "openhtf.test_record.24946:4e82dcd8bf194e23:f0e1c9eaadd04447:1720169754059.phase.my_test_phase",
      "source": "first-testbench-ui.py",
      "lineno": 28,
      "timestamp_millis": 1720169754060,
      "message": "Plug incremented value to: 0"
    },
    ...
    {
      "level": 10,
      "logger_name": "openhtf.plugs",
      "source": "__init__.py",
      "lineno": 334,
      "timestamp_millis": 1720169754060,
      "message": "Tearing down all plugs."
    },
    {
      "level": 20,
      "logger_name": "openhtf.test_record.24946:4e82dcd8bf194e23:f0e1c9eaadd04447:1720169754059.plug.ExamplePlug",
      "source": "first-testbench-ui.py",
      "lineno": 19,
      "timestamp_millis": 1720169754060,
      "message": "Tearing down <ExamplePlug: 1>"
    },
    ...
  ],
}
```

## Plug example 1: YKUSH USB hub

[YKUSH USB](https://www.yepkit.com/products/ykush) hubs are programmable USB hubs that allow users to control the power state of individual USB ports programmatically. These hubs are typically used in test benches for automated testing and development environments, where devices need to be power-cycled or reset remotely without manual intervention.

<Image src="/ykush.png" alt="YKUSH USB hub" />

This plug design for the YKUSH USB hub allows programmatic control of USB port power states. Configuration settings specify the port number, initialization sets up the plug, and the teardown method is empty since no cleanup is needed. The plug uses the `ykushcmd` utility to switch the USB ports on and off.

<Note>
  You need to have the hardware connected and the driver installed from the
  manufacturer's website for this code example to work.
</Note>

```python {{ title: 'main.py' }}
import openhtf as htf
import logging
from openhtf.core import base_plugs
from openhtf.util import conf
from openhtf.output.callbacks import json_factory
import subprocess

# Define configuration options
conf.declare('ykush_port', default_value=0, description='Port number on the YKUSH hub to control.')

class YKUSHPlug(base_plugs.BasePlug):
    def __init__(self):
        # Initialize the port from configuration
        self.port = conf.ykush_port

    def power_on(self):
        # Power on the specified port
        subprocess.run(['ykushcmd', '-u', str(self.port)], check=True)
        self.logger.info('Powered on port %d', self.port)

    def power_off(self):
        # Power off the specified port
        subprocess.run(['ykushcmd', '-d', str(self.port)], check=True)
        self.logger.info('Powered off port %d', self.port)

    def tearDown(self):
        # Log teardown process
        self.logger.info('Tearing down YKUSH plug for port %d', self.port)

@htf.plug(ykush_plug=YKUSHPlug)
def control_usb_port(test, ykush_plug):
    # Power on the USB port and log the action
    ykush_plug.power_on()
    test.logger.info('USB port powered on.')
    # Simulate some test operations
    ykush_plug.power_off()
    test.logger.info('USB port powered off.')

def main():
    logging.basicConfig(level=logging.INFO)
    # Create an OpenHTF test with the control_usb_port phase
    test = htf.Test(control_usb_port)
    # Add JSON output callback to log test results in test_results.json
    test.add_output_callbacks(json_factory.OutputToJSON('./test_results.json', indent=2))
    # Execute the test, providing a lambda function to return the device ID
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

## Plug example 2: Firmata

This plug design for a Firmata-based device allows for programmatic control and monitoring of pin states on a microcontroller like Arduino or Teensy. Using Firmata, you can abstract away the serial communication protocol, simplifying the interaction between the microcontroller and OpenHTF.

The plug uses the PyMata library to interface with the Firmata firmware on the device. Configuration settings specify the serial port, and the plug methods handle setting pin modes and reading digital values.

```sh
pip install PyMata
```

### How to install Firmata on a board

1. **Install the Arduino IDE**: Download from the [official Arduino website](https://www.arduino.cc/en/software).

2. **Open the Firmata Example**: Launch Arduino IDE and navigate to `File` > `Examples` > `Firmata` > `StandardFirmata`.

3. **Connect Your Board**: Connect your Arduino or Teensy board via USB.

4. **Select Your Board and Port**: Go to `Tools` > `Board` and select your model. Then, go to `Tools` > `Port` and select the correct port.

5. **Upload the Firmata Firmware**: Click the upload button to upload the StandardFirmata sketch to your board.

### OpenHTF plug example

<Note>
  You need to have the hardware connected and the Firmata firmware installed on
  the microcontroller for this code example to work.
</Note>

```python {{ title: 'main.py' }}
import openhtf as htf
import logging
from openhtf.core import base_plugs
from openhtf.util import conf
from openhtf.output.callbacks import json_factory
from PyMata.pymata import PyMata
import time

# Define configuration options
conf.declare('firmata_com_port', default_value='/dev/ttyACM0', description='COM Port of Firmata Board')

class FirmataPlug(base_plugs.BasePlug):

    @conf.inject_positional_args
    def __init__(self, firmata_com_port):
        self._board = PyMata(firmata_com_port, verbose=False)

    def set_digital_input(self, pin):
        self._board.set_pin_mode(pin, self._board.INPUT, self._board.DIGITAL)
        time.sleep(1)

    def digital_read(self, pin):
        return self._board.digital_read(pin)

    def tearDown(self):
        self._board.close()
        self.logger.info('Closed connection to Firmata board.')

@htf.plug(board=FirmataPlug)
def digital_read_phase(test, board):
    board.set_digital_input(4)
    board.set_digital_input(5)
    board.set_digital_input(6)
    test.measurements.P4_digital = board.digital_read(4)
    test.measurements.P5_digital = board.digital_read(5)
    test.measurements.P6_digital = board.digital_read(6)
    test.logger.info('Completed digital read phase.')

def main():
    logging.basicConfig(level=logging.INFO)
    test = htf.Test(digital_read_phase)
    test.add_output_callbacks(json_factory.OutputToJSON('./test_results.json', indent=2))
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```
