export const metadata = {
  title: 'Plugs | OpenHTF',
  description:
    'Discover how to use OpenHTF’s powerful plugin system, known as "plugs," to abstract hardware interactions and encapsulate reusable test logic. Includes examples of simple plug implementation and configuration.',
}

# Plugs

OpenHTF provides a powerful plugin system, known as "plugs," which allows to abstract hardware interactions. They can be used to encapsulate reusable test logic, hardware interfaces, or any other functionality you need. {{ className: 'lead' }}

A plug is a class that inherits from `plugs.BasePlug` and can implement a `tearDow`. They can wrap existing Python objects for seamless integration​.

## Simple plug

This example demonstrates a simple plug that maintains a value and increments it. The plug supports a teardown process and maintains state across test phases. Plugs can be injected into test phases using the `@htf.plug` decorator.

```python {{ title: 'main.py' }}
import openhtf as htf
from openhtf.core import base_plugs

class ExamplePlug(base_plugs.BasePlug):
    def __init__(self, increment_size=1):
        self.increment_size = increment_size
        self.value = 0

    def tearDown(self):
        self.logger.info('Tearing down %s', self)

    def increment(self):
        self.value += self.increment_size
        return self.value - self.increment_size

@htf.plug(my_plug=ExamplePlug)
def my_test_phase(test, my_plug):
    result = my_plug.increment()
    test.logger.info('Plug incremented value to: %s', result)

def main():
    test = htf.Test(my_test_phase)
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

## Plug configuration and output

Plugs can also have their own configurations. You can declare configuration options and load them similarly to how you do it for tests.

```python {{ title: 'main.py' }}
import openhtf as htf
import logging
from openhtf.core import base_plugs
from openhtf.util import conf
from openhtf.output.callbacks import json_factory

# Define configuration options
conf.declare('example_plug_increment_size', default_value=1, description='Increment constant for example plug.')

class ExamplePlug(base_plugs.BasePlug):
    def __init__(self):
        self.increment_size = conf.example_plug_increment_size
        self.value = 0

    def __str__(self):
        return '<%s: %s>' % (type(self).__name__, self.value)

    def tearDown(self):
        self.logger.info('Tearing down %s', self)

    def increment(self):
        self.value += self.increment_size
        return self.value - self.increment_size

@htf.plug(my_plug=ExamplePlug)
def my_test_phase(test, my_plug):
    result = my_plug.increment()
    test.logger.info('Plug incremented value to: %s', result)

def main():
    logging.basicConfig(level=logging.INFO)
    test = htf.Test(my_test_phase)
    test.add_output_callbacks(json_factory.OutputToJSON('./test_results.json', indent=2))
    test.execute(test_start=lambda: 'DeviceUnderTest123')

if __name__ == '__main__':
    main()
```

When output is enabled, the plug's activity will be included in the JSON output file.

```javascript {{ title: 'test_results.json' }}
{
  "dut_id": "DeviceUnderTest123",
  ...
  "log_records": [
    ...
    {
      "level": 20,
      "logger_name": "openhtf.test_record.24946:4e82dcd8bf194e23:f0e1c9eaadd04447:1720169754059.phase.my_test_phase",
      "source": "first-testbench-ui.py",
      "lineno": 28,
      "timestamp_millis": 1720169754060,
      "message": "Plug incremented value to: 0"
    },
    ...
    {
      "level": 10,
      "logger_name": "openhtf.plugs",
      "source": "__init__.py",
      "lineno": 334,
      "timestamp_millis": 1720169754060,
      "message": "Tearing down all plugs."
    },
    {
      "level": 20,
      "logger_name": "openhtf.test_record.24946:4e82dcd8bf194e23:f0e1c9eaadd04447:1720169754059.plug.ExamplePlug",
      "source": "first-testbench-ui.py",
      "lineno": 19,
      "timestamp_millis": 1720169754060,
      "message": "Tearing down <ExamplePlug: 1>"
    },
    ...
  ],
}
```
